This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-28T00:21:17.927Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
backend/
  db_models/
    db_schema.py
  ml/
    ml_model.py
  scripts/
    ingest_historical_stats.py
    init_db.py
    test_ingestion.py
  app.py
  db_config.py
  dockerfile
  readme.md
  requirements.txt
frontend/
  components/
    BettingDashboard.jsx
    BettingTabs.jsx
    TopPicks.js
  pages/
    _app.js
    index.js
  styles/
    globals.css
  dockerfile
  package.json
  postcss.config.js
  tailwind.config.js
notes/
  testing/
    nba_api_sandbox.py
  nba_api.md
  pandas.md
  todo.txt
.env.example
.gitignore
docker-compose.yml
readme.md

================================================================
Files
================================================================

================
File: backend/db_models/db_schema.py
================
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from backend.db_config import Base

class Player(Base):
    __tablename__ = 'players'
    __tableargs__ = {'extend_existing': True}
    
    id = Column(Integer, primary_key=True)
    player_id = Column(Integer, unique=True)
    full_name = Column(String)
    is_active = Column(Boolean, default=True)

class PlayerStats(Base):
    __tablename__ = 'player_stats'
    __tableargs__ = {'extend_existing': True}

    id = Column(Integer, primary_key=True)
    game_id = Column(String)
    player_id = Column(Integer)
    game_date = Column(DateTime)
    season = Column(String)
    is_home_game = Column(Boolean)
    minutes_played = Column(String)
    points = Column(Integer)
    assists = Column(Integer)
    rebounds = Column(Integer)
    steals = Column(Integer)
    blocks = Column(Integer)
    turnovers = Column(Integer)
    plus_minus = Column(Integer)
    fg_made = Column(Integer)
    fg_attempted = Column(Integer)
    fg3_made = Column(Integer)
    fg3_attempted = Column(Integer)
    ft_made = Column(Integer)
    ft_attempted = Column(Integer)

================
File: backend/ml/ml_model.py
================
from typing import Tuple, Dict, List, Optional, Union
import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import pandas as pd
from sqlalchemy.orm import Session
from backend.models.db_schema import PlayerStats, Player
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('ml_model.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class NBAPredictor(nn.Module):
    def __init__(self, input_size: int = 15, hidden_size: int = 64, output_size: int = 1):
        """
        Neural network model for predicting NBA player performance.
        
        Args:
            input_size: Number of input features (default 15 for player stats)
            hidden_size: Size of hidden layers
            output_size: Size of output layer (1 for regression predictions)
        """
        super(NBAPredictor, self).__init__()
        
        # Define neural network architecture
        self.model = nn.Sequential(
            nn.Linear(input_size, hidden_size),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(hidden_size, hidden_size // 2),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(hidden_size // 2, output_size)
        )
        
        # Initialize weights using Xavier initialization
        for m in self.modules():
            if isinstance(m, nn.Linear):
                nn.init.xavier_normal_(m.weight)
                nn.init.constant_(m.bias, 0)
        
        # Model training state
        self.is_trained = False
        self.scaler = None  # Will store feature scaler
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """Forward pass through the network"""
        return self.model(x)
    
    def train_model(self, 
                   X_train: torch.Tensor, 
                   y_train: torch.Tensor, 
                   epochs: int = 100, 
                   lr: float = 0.001, 
                   batch_size: int = 64) -> Dict[str, List[float]]:
        """
        Train the model using the provided training data.
        
        Args:
            X_train: Training features tensor
            y_train: Training target tensor
            epochs: Number of training epochs
            lr: Learning rate
            batch_size: Batch size for training
            
        Returns:
            Dictionary containing training history
        """
        criterion = nn.MSELoss()
        optimizer = optim.Adam(self.parameters(), lr=lr)
        
        # Create data loaders
        dataset = torch.utils.data.TensorDataset(X_train, y_train)
        dataloader = torch.utils.data.DataLoader(dataset, batch_size=batch_size, shuffle=True)
        
        history = {"loss": []}
        
        # Training loop
        self.train()  # Set model to training mode
        for epoch in range(epochs):
            running_loss = 0.0
            for inputs, targets in dataloader:
                # Zero the parameter gradients
                optimizer.zero_grad()
                
                # Forward pass
                outputs = self(inputs)
                loss = criterion(outputs, targets)
                
                # Backward pass and optimize
                loss.backward()
                optimizer.step()
                
                running_loss += loss.item()
            
            # Log epoch loss
            epoch_loss = running_loss / len(dataloader)
            history["loss"].append(epoch_loss)
            if epoch % 10 == 0:
                logger.info(f'Epoch {epoch} | Loss: {epoch_loss:.6f}')
        
        self.is_trained = True
        return history
    
    def predict(self, features: torch.Tensor) -> torch.Tensor:
        """
        Make predictions using the trained model.
        
        Args:
            features: Input features tensor
            
        Returns:
            Prediction tensor
        """
        if not self.is_trained:
            raise RuntimeError("Model must be trained before making predictions")
        
        self.eval()  # Set model to evaluation mode
        with torch.no_grad():
            return self(features)
    
    def save_model(self, path: str) -> None:
        """
        Save the model to a file.
        
        Args:
            path: Path to save the model
        """
        model_state = {
            'model_state_dict': self.state_dict(),
            'is_trained': self.is_trained,
        }
        torch.save(model_state, path)
        logger.info(f"Model saved to {path}")
    
    def load_model(self, path: str) -> None:
        """
        Load the model from a file.
        
        Args:
            path: Path to load the model from
        """
        try:
            model_state = torch.load(path)
            self.load_state_dict(model_state['model_state_dict'])
            self.is_trained = model_state['is_trained']
            logger.info(f"Model loaded from {path}")
        except Exception as e:
            logger.error(f"Error loading model: {str(e)}")
            raise


class PlayerPropPredictor:
    """Helper class to manage player prop predictions"""
    
    def __init__(self, model_path: Optional[str] = None):
        """
        Initialize the prop predictor with models for different stat categories.
        
        Args:
            model_path: Optional path to load saved models
        """
        # Create models for different stat categories
        self.models = {
            'points': NBAPredictor(),
            'rebounds': NBAPredictor(),
            'assists': NBAPredictor(),
            'steals': NBAPredictor(),
            'blocks': NBAPredictor(),
            'threes': NBAPredictor()
        }
        
        # Load models if path provided
        if model_path:
            try:
                for stat, model in self.models.items():
                    model.load_model(f"{model_path}/{stat}_model.pt")
            except Exception as e:
                logger.error(f"Failed to load models: {str(e)}")
    
    def prepare_player_features(self, session: Session, player_id: int, n_games: int = 10) -> Dict[str, torch.Tensor]:
        """
        Prepare features for a player based on recent game history.
        
        Args:
            session: Database session
            player_id: NBA player ID
            n_games: Number of recent games to use
            
        Returns:
            Dictionary of feature tensors for each stat category
        """
        try:
            # Query recent games for the player
            recent_games = session.query(PlayerStats).filter_by(player_id=player_id)\
                            .order_by(PlayerStats.game_date.desc())\
                            .limit(n_games).all()
            
            if not recent_games:
                logger.warning(f"No recent games found for player {player_id}")
                return {}
            
            # Extract features for each stat category
            features = {}
            for stat in self.models.keys():
                # Build appropriate features for each stat type
                if stat == 'points':
                    raw_features = [
                        [g.points, g.fg_made, g.fg_attempted, g.fg3_made, g.fg3_attempted, 
                         g.ft_made, g.ft_attempted, g.minutes_played, g.is_home_game, 
                         g.plus_minus, g.season, g.turnovers, g.assists, g.rebounds, g.blocks]
                        for g in recent_games
                    ]
                elif stat == 'rebounds':
                    raw_features = [
                        [g.rebounds, g.points, g.blocks, g.minutes_played, g.is_home_game,
                         g.plus_minus, g.season, g.turnovers, g.assists, g.fg_attempted,
                         g.fg3_attempted, g.ft_attempted, g.fg_made, g.fg3_made, g.ft_made]
                        for g in recent_games
                    ]
                elif stat == 'assists':
                    raw_features = [
                        [g.assists, g.points, g.turnovers, g.minutes_played, g.is_home_game,
                         g.plus_minus, g.season, g.rebounds, g.fg_attempted, g.fg3_attempted,
                         g.ft_attempted, g.fg_made, g.fg3_made, g.ft_made, g.blocks]
                        for g in recent_games
                    ]
                elif stat == 'threes':
                    raw_features = [
                        [g.fg3_made, g.fg3_attempted, g.points, g.minutes_played, g.is_home_game,
                         g.plus_minus, g.season, g.turnovers, g.assists, g.rebounds,
                         g.fg_attempted, g.fg_made, g.ft_attempted, g.ft_made, g.blocks]
                        for g in recent_games
                    ]
                else:  # steals and blocks use similar features
                    raw_features = [
                        [getattr(g, stat), g.points, g.minutes_played, g.is_home_game,
                         g.plus_minus, g.season, g.turnovers, g.assists, g.rebounds,
                         g.fg_attempted, g.fg3_attempted, g.ft_attempted, g.fg_made, 
                         g.fg3_made, g.ft_made]
                        for g in recent_games
                    ]
                
                # Convert to tensor
                features[stat] = torch.tensor(raw_features, dtype=torch.float32)
            
            return features
            
        except Exception as e:
            logger.error(f"Error preparing features: {str(e)}")
            return {}
    
    def predict_prop(self, 
                    stat_category: str, 
                    features: torch.Tensor, 
                    prop_line: float,
                    n_samples: int = 100) -> Tuple[str, float]:
        """
        Predict over/under for a prop with confidence.
        
        Args:
            stat_category: Category of the stat ('points', 'rebounds', etc.)
            features: Tensor of player features
            prop_line: The betting line (e.g., 22.5 points)
            n_samples: Number of Monte Carlo samples for confidence
            
        Returns:
            Tuple of (prediction, confidence)
            prediction is "Over" or "Under"
            confidence is a float between 0 and 1
        """
        if stat_category not in self.models:
            raise ValueError(f"Unknown stat category: {stat_category}")
        
        model = self.models[stat_category]
        if not model.is_trained:
            raise RuntimeError(f"Model for {stat_category} not trained")
        
        # Use Monte Carlo dropout for uncertainty estimation
        model.train()  # Enable dropout for MC sampling
        predictions = []
        
        for _ in range(n_samples):
            with torch.no_grad():
                # Use the most recent game's features
                pred = model(features[0].unsqueeze(0)).item()
                predictions.append(pred)
        
        # Calculate mean prediction and standard deviation
        mean_pred = np.mean(predictions)
        std_dev = np.std(predictions)
        
        # Determine if over or under
        prediction = "Over" if mean_pred > prop_line else "Under"
        
        # Calculate confidence based on distance from line and uncertainty
        z_score = abs(mean_pred - prop_line) / (std_dev + 1e-10)  # Add small epsilon to avoid division by zero
        confidence = min(0.5 + 0.5 * (1 - np.exp(-0.5 * z_score)), 0.95)  # Cap at 95%
        
        return prediction, confidence


def get_prediction_with_confidence(model: NBAPredictor, 
                                  game_data: Dict, 
                                  n_samples: int = 100) -> Tuple[float, float]:
    """
    Get a prediction and confidence score for a game outcome.
    
    Args:
        model: Trained NBAPredictor model
        game_data: Dictionary of game data features
        n_samples: Number of Monte Carlo samples for uncertainty
        
    Returns:
        Tuple of (prediction, confidence)
        prediction is the predicted value
        confidence is a value between 0 and 1
    """
    # Convert game data to tensor
    features = []
    for key in ['team', 'opponent', 'is_home_game', 'season']:
        if key in game_data:
            features.append(game_data[key])
    
    features_tensor = torch.tensor(features, dtype=torch.float32).unsqueeze(0)
    
    # Use Monte Carlo dropout for uncertainty estimation
    model.train()  # Enable dropout
    predictions = []
    
    for _ in range(n_samples):
        with torch.no_grad():
            pred = model(features_tensor).item()
            predictions.append(pred)
    
    # Calculate mean and standard deviation
    mean_pred = np.mean(predictions)
    std_dev = np.std(predictions)
    
    # Calculate confidence (lower std_dev = higher confidence)
    confidence = 1.0 / (1.0 + std_dev)
    
    return mean_pred, confidence


# Example usage function
def train_prop_models(session: Session, save_path: str = 'models/'):
    """
    Train models for all prop types using data from the database.
    
    Args:
        session: Database session
        save_path: Directory to save trained models
    """
    import os
    os.makedirs(save_path, exist_ok=True)
    
    prop_predictor = PlayerPropPredictor()
    
    # Training data for each stat category
    for stat in prop_predictor.models.keys():
        logger.info(f"Training model for {stat}...")
        
        # Get training data from database
        # In a real app, you would get this data from your database
        # For demonstration purposes, we'll use random data
        
        # Create random training data
        X_train = torch.rand(1000, 15)  # 1000 samples, 15 features
        y_train = torch.rand(1000, 1)   # 1000 targets
        
        # Train model
        prop_predictor.models[stat].train_model(X_train, y_train, epochs=50)
        
        # Save model
        prop_predictor.models[stat].save_model(f"{save_path}/{stat}_model.pt")
        
    logger.info("All models trained and saved successfully.")

================
File: backend/scripts/ingest_historical_stats.py
================
import sys
from pathlib import Path

# Add the backend directory to the path so we can import from models
backend_dir = Path(__file__).resolve().parent.parent
sys.path.append(str(backend_dir))

from nba_api.stats.static import players
from nba_api.stats.endpoints import leaguegamefinder
import pandas as pd
import time
from datetime import datetime
from typing import List, Dict
from sqlalchemy.orm import Session
from backend.db_models.db_schema import PlayerStats, Player
from backend.db_config import engine
import logging
import random
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

log_path = Path(__file__).parent / 'nba_stats_ingestion.log'
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('nba_stats_ingestion.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class NBADataIngestion:
    def __init__(self):
        """Initialize the NBA data ingestion module."""
        self.current_season = datetime.now().year
        self.seasons = [
            f"{year}-{str(year + 1)[-2:]}" 
            for year in range(self.current_season - 5, self.current_season)
        ]
        
        retry_strategy = Retry(
            total=5,
            backoff_factor=2,
            status_forcelist=[429, 500, 502, 503, 504]
        )

        self.http_adapter = HTTPAdapter(max_retries=retry_strategy)
        self.http_session = requests.Session()
        self.http_session.mount("https://", self.http_adapter)
        self.http_session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        
    def get_active_players(self) -> List[Dict]:
        try:
            active_players = players.get_active_players()
            logger.info(f"Found {len(active_players)} active players")
            return active_players
        except Exception as e:
            logger.error(f"Error fetching active players: {e}")
            return []

    def get_player_games(self, player_id: int, season: str) -> pd.DataFrame:
        max_retries = 5  
        current_retry = 0
        base_delay = 2 
        
        while current_retry < max_retries:
            try:
                delay = base_delay * (2 ** current_retry) + random.uniform(1.0, 3.0)
                time.sleep(delay)
                
                player_games_query = leaguegamefinder.LeagueGameFinder(
                    player_or_team_abbreviation="P",
                    player_id_nullable=player_id,
                    season_nullable=season,
                    season_type_nullable="Regular Season",
                    timeout=180 
                )
                
                headers = {
                    'User-Agent': f'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/{random.randint(80, 108)}.0.0.0'
                }
                self.http_session.headers.update(headers)
                
                games_df = player_games_query.get_data_frames()[0]
                if not games_df.empty:
                    logger.info(f"Successfully retrieved data for player {player_id}")
                    return games_df
                
                return pd.DataFrame()
                    
            except Exception as e:
                current_retry += 1
                if current_retry < max_retries:
                    logger.warning(f"Attempt {current_retry} failed: {e}")
                    continue
                else:
                    logger.error(f"Failed after {max_retries} attempts: {e}")
                    return pd.DataFrame()

    def process_game_data(self, game_data: pd.Series, season: str) -> Dict:
        try:
            return {
                'game_id': game_data['GAME_ID'],
                'player_id': game_data['PLAYER_ID'],
                'game_date': pd.to_datetime(game_data['GAME_DATE']),
                'season': season,
                'is_home_game': '@' not in game_data['MATCHUP'],
                'minutes_played': game_data['MIN'],
                'points': game_data['PTS'],
                'rebounds': game_data['REB'],
                'assists': game_data['AST'],
                'steals': game_data['STL'],
                'blocks': game_data['BLK'],
                'turnovers': game_data['TOV'],
                'plus_minus': game_data['PLUS_MINUS'],
                'fg_made': game_data['FGM'],
                'fg_attempted': game_data['FGA'],
                'fg3_made': game_data['FG3M'],
                'fg3_attempted': game_data['FG3A'],
                'ft_made': game_data['FTM'],
                'ft_attempted': game_data['FTA']
            }
        except Exception as e:
            logger.error(f"Error processing game data: {e}")
            return None

    def store_player_data(self, player: Dict):
        with Session(engine) as session:
            try:
                existing_player = session.query(Player).filter_by(player_id=player['id']).first()
                
                if existing_player:
                    existing_player.full_name = player['full_name']
                    existing_player.is_active = True
                else:
                    player_record = Player(
                        player_id=player['id'],
                        full_name=player['full_name'],
                        is_active=True
                    )
                    session.add(player_record)
                
                session.commit()
            except Exception as e:
                logger.error(f"Error storing player data: {e}")
                session.rollback()

    def store_game_stats(self, stats_data: Dict):
        if not stats_data:
            return
            
        with Session(engine) as session:
            try:
                stats = PlayerStats(**stats_data)
                session.merge(stats)
                session.commit()
            except Exception as e:
                logger.error(f"Error storing game stats: {e}")
                session.rollback()

    def run_ingestion(self):
        logger.info("Starting historical data ingestion")
        logger.info(f"Will collect data for seasons: {', '.join(self.seasons)}")
        logger.info("=" * 80)
        
        active_players = self.get_active_players()
        total_players = len(active_players)
        
        for idx, player in enumerate(active_players, 1):
            try:
                logger.info(f"Processing player {idx}/{total_players}: {player['full_name']}")
                self.store_player_data(player)
                for season in self.seasons:
                    games_df = self.get_player_games(player['id'], season)
                    
                    if games_df.empty:
                        continue
                    
                    for _, game in games_df.iterrows():
                        processed_data = self.process_game_data(game, season)
                        self.store_game_stats(processed_data)
                    
                    logger.info(f"Processed {len(games_df)} games for {player['full_name']} in {season}")
                
            except Exception as e:
                logger.error(f"Error processing player {player['full_name']}: {e}")
                continue
            
            time.sleep(random.uniform(1, 3))
            logger.info("=" * 80)

        logger.info("Historical data ingestion completed")

if __name__ == "__main__":
    ingestion = NBADataIngestion()
    ingestion.run_ingestion()

================
File: backend/scripts/init_db.py
================
import os
import sys
from sqlalchemy import create_engine, inspect, text
from sqlalchemy.orm import sessionmaker
from sqlalchemy_utils import database_exists, create_database
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

from backend.db_config import Base, engine  
from backend.models.db_schema import Player, PlayerStats

def init_database():
    try:
        if not database_exists(engine.url):
            logger.info(f"Creating database at {engine.url}")
            create_database(engine.url)
        
        logger.info("Creating tables if they don't exist...")
        Base.metadata.create_all(engine)
        
        inspector = inspect(engine)
        tables = inspector.get_table_names()
        logger.info("Created tables: " + ", ".join(tables))
        
        Session = sessionmaker(bind=engine)
        session = Session()
        session.execute(text("SELECT 1"))
        session.close()
        
        logger.info("Database initialization completed successfully!")
        return True
        
    except Exception as e:
        logger.error(f"Error initializing database: {e}")
        return False

if __name__ == "__main__":
    if init_database():
        logger.info("Database is ready!")
    else:
        logger.error("Database initialization failed!")

================
File: backend/scripts/test_ingestion.py
================
import sys
import random
from pathlib import Path
import unittest
import pandas as pd
from datetime import datetime
from sqlalchemy.orm import Session

script_dir = Path(__file__).resolve().parent  # .../backend/scripts
backend_dir = script_dir.parent               # .../backend
project_root = backend_dir.parent             # .../Sharpshooter Picks
sys.path.append(str(project_root))            # Add the actual project root

# Import with relative paths
from ingest_historical_stats import NBADataIngestion  # Same directory import
from db_config import engine  # From parent directory
from db_models.db_schema import Player, PlayerStats  # From parent's subdirectory

class TestNBAIngestion:
    """Class for testing components of the NBA data ingestion process"""
    
    def __init__(self):
        self.ingestion = NBADataIngestion()
        self.session = Session(engine)
    
    def cleanup(self):
        """Clean up resources"""
        self.session.close()
    
    def test_player_api(self):
        """Test the NBA API player retrieval"""
        print("\n----- Testing NBA API Player Retrieval -----")
        active_players = self.ingestion.get_active_players()
        
        if not active_players:
            print("❌ Failed to retrieve active players")
            return False
        
        print(f"✅ Successfully retrieved {len(active_players)} active players")
        
        # Print a few sample players to verify data structure
        if active_players:
            print("\nSample player data:")
            for i, player in enumerate(random.sample(active_players, min(3, len(active_players)))):
                print(f"  {i+1}. {player['full_name']} (ID: {player['id']})")
                
        return len(active_players) > 0
    
    def test_game_api(self, player_id=None, season="2023-24"):
        """Test the NBA API game retrieval for a specific player"""
        print(f"\n----- Testing NBA API Game Retrieval for Season {season} -----")
        
        # If no player_id is provided, get one from the API
        if player_id is None:
            active_players = self.ingestion.get_active_players()
            if not active_players:
                print("❌ Failed to retrieve players to test game API")
                return False
            
            # Select a popular player who will likely have games
            popular_players = ["LeBron James", "Stephen Curry", "Kevin Durant", "Jayson Tatum", "Luka Doncic"]
            player = None
            
            for name in popular_players:
                for p in active_players:
                    if p['full_name'] == name:
                        player = p
                        break
                if player:
                    break
                    
            if not player:
                # Just pick a random player if none of the popular ones are found
                player = random.choice(active_players)
            
            player_id = player['id']
            print(f"Selected player: {player['full_name']} (ID: {player_id})")
        
        # Retrieve games for the player
        games_df = self.ingestion.get_player_games(player_id, season)
        
        if games_df is None or games_df.empty:
            print(f"❌ Failed to retrieve games for player ID {player_id} in season {season}")
            return False
        
        print(f"✅ Successfully retrieved {len(games_df)} games for player ID {player_id}")
        
        # Print available columns to understand the data structure
        print("\nAvailable columns:")
        print(", ".join(games_df.columns.tolist()))
        
        # Print a sample game
        if not games_df.empty:
            print("\nSample game data:")
            sample_game = games_df.iloc[0]
            
            relevant_cols = [
                'GAME_ID', 'GAME_DATE', 'MATCHUP', 'WL', 
                'MIN', 'PTS', 'REB', 'AST', 'STL', 'BLK', 
                'TOV', 'PLUS_MINUS', 'FGM', 'FGA', 'FG3M', 'FG3A', 
                'FTM', 'FTA'
            ]
            
            # Only show columns that exist in the dataframe
            cols_to_show = [col for col in relevant_cols if col in sample_game.index]
            
            for col in cols_to_show:
                print(f"  {col}: {sample_game[col]}")
        
        return not games_df.empty
    
    def test_process_game_data(self, player_id=None, season="2023-24"):
        """Test the game data processing functionality"""
        print("\n----- Testing Game Data Processing -----")
        
        # First, get a real game to process
        if player_id is None:
            # Get a player
            active_players = self.ingestion.get_active_players()
            if not active_players:
                print("❌ Failed to retrieve players to test data processing")
                return False
            
            # Select a popular player
            player = None
            for p in active_players:
                if p['full_name'] in ["LeBron James", "Stephen Curry", "Giannis Antetokounmpo"]:
                    player = p
                    break
            
            if not player:
                player = random.choice(active_players)
            
            player_id = player['id']
        
        # Get games for the player
        games_df = self.ingestion.get_player_games(player_id, season)
        
        if games_df is None or games_df.empty:
            print(f"❌ No games found for player ID {player_id} in season {season}")
            return False
        
        # Select a random game
        sample_game = games_df.iloc[random.randint(0, len(games_df) - 1)]
        
        # Process the game data
        processed_data = self.ingestion.process_game_data(sample_game, season)
        
        if processed_data is None:
            print("❌ Failed to process game data")
            return False
        
        print("✅ Successfully processed game data")
        print("\nProcessed game fields:")
        
        # Print the processed fields
        for key, value in processed_data.items():
            print(f"  {key}: {value}")
        
        # Verify all required fields are present
        expected_fields = [
            'game_id', 'player_id', 'game_date', 'season', 'is_home_game',
            'minutes_played', 'points', 'rebounds', 'assists', 'steals',
            'blocks', 'turnovers', 'plus_minus', 'fg_made', 'fg_attempted',
            'fg3_made', 'fg3_attempted', 'ft_made', 'ft_attempted'
        ]
        
        missing_fields = [field for field in expected_fields if field not in processed_data]
        
        if missing_fields:
            print(f"❌ Missing fields in processed data: {', '.join(missing_fields)}")
            return False
        
        print("✅ All required fields are present in the processed data")
        return True
    
    def test_db_connection_and_schema(self):
        """Test database connection and verify schema"""
        print("\n----- Testing Database Connection and Schema -----")
        
        try:
            # Check if we can query the database
            player_count = self.session.query(Player).count()
            stats_count = self.session.query(PlayerStats).count()
            
            print(f"✅ Database connection successful")
            print(f"  Current database contains {player_count} players and {stats_count} game stats records")
            
            # Check Player table columns
            player_columns = [column.name for column in Player.__table__.columns]
            print("\nPlayer table columns:", ", ".join(player_columns))
            
            # Check PlayerStats table columns
            stats_columns = [column.name for column in PlayerStats.__table__.columns]
            print("\nPlayerStats table columns:", ", ".join(stats_columns))
            
            return True
            
        except Exception as e:
            print(f"❌ Database connection error: {e}")
            return False
    
    def test_single_player_ingestion(self, player_id=None, season="2023-24", limit_games=2):
        """Test the ingestion process for a single player with limited games"""
        print("\n----- Testing Single Player Ingestion Process -----")
        
        # Get a player to test
        if player_id is None:
            active_players = self.ingestion.get_active_players()
            if not active_players:
                print("❌ Failed to retrieve players for testing")
                return False
            
            # Select a random player
            player = random.choice(active_players)
            player_id = player['id']
            print(f"Selected player: {player['full_name']} (ID: {player_id})")
        else:
            # Get player info
            active_players = self.ingestion.get_active_players()
            player = next((p for p in active_players if p['id'] == player_id), None)
            if player:
                print(f"Using player: {player['full_name']} (ID: {player_id})")
            else:
                print(f"Using player ID: {player_id} (name unknown)")
        
        # Store player in database
        print("\nStoring player in database...")
        if player:
            self.ingestion.store_player_data(player)
        else:
            # Create a minimal player record if the player info wasn't found
            self.ingestion.store_player_data({
                'id': player_id,
                'full_name': f"TestPlayer_{player_id}",
                'is_active': True
            })
        
        # Verify player was stored
        db_player = self.session.query(Player).filter_by(player_id=player_id).first()
        if not db_player:
            print("❌ Failed to store player in database")
            return False
        
        print(f"✅ Player stored successfully: {db_player.full_name}")
        
        # Get games for the player
        print(f"\nRetrieving games for player from season {season}...")
        games_df = self.ingestion.get_player_games(player_id, season)
        
        if games_df is None or games_df.empty:
            print(f"❌ No games found for player ID {player_id} in season {season}")
            return False
        
        # Limit the number of games for testing
        games_to_process = games_df.head(limit_games)
        print(f"✅ Retrieved {len(games_df)} games, will process {len(games_to_process)}")
        
        # Process and store each game
        successful_games = 0
        for _, game in games_to_process.iterrows():
            try:
                processed_data = self.ingestion.process_game_data(game, season)
                if processed_data:
                    self.ingestion.store_game_stats(processed_data)
                    successful_games += 1
            except Exception as e:
                print(f"❌ Error processing game: {e}")
        
        print(f"✅ Successfully processed and stored {successful_games} out of {len(games_to_process)} games")
        
        # Verify games were stored
        db_stats = self.session.query(PlayerStats).filter_by(player_id=player_id).all()
        
        if not db_stats:
            print("❌ No game stats were stored in the database")
            return False
        
        print(f"✅ Found {len(db_stats)} games in database for player {player_id}")
        
        # Show a sample of the stored data
        if db_stats:
            print("\nSample of stored game data:")
            sample_stat = db_stats[0]
            print(f"  Game ID: {sample_stat.game_id}")
            print(f"  Date: {sample_stat.game_date}")
            print(f"  Points: {sample_stat.points}")
            print(f"  Rebounds: {sample_stat.rebounds}")
            print(f"  Assists: {sample_stat.assists}")
        
        return successful_games > 0
    
    def verify_data_in_tables(self, player_id=None):
        """Verify the data in the database tables"""
        print("\n----- Verifying Data in Database Tables -----")
        
        # Get stats for a specific player if provided
        if player_id:
            player = self.session.query(Player).filter_by(player_id=player_id).first()
            if not player:
                print(f"❌ Player ID {player_id} not found in database")
                return False
            
            print(f"Found player: {player.full_name} (ID: {player.player_id})")
            
            stats = self.session.query(PlayerStats).filter_by(player_id=player_id).all()
            print(f"Found {len(stats)} game stats for this player")
            
            if stats:
                print("\nSeason breakdown:")
                stats_by_season = {}
                for stat in stats:
                    if stat.season not in stats_by_season:
                        stats_by_season[stat.season] = 0
                    stats_by_season[stat.season] += 1
                
                for season, count in stats_by_season.items():
                    print(f"  {season}: {count} games")
        else:
            # Get overall database stats
            player_count = self.session.query(Player).count()
            active_player_count = self.session.query(Player).filter_by(is_active=True).count()
            stats_count = self.session.query(PlayerStats).count()
            
            print(f"Total players in database: {player_count} ({active_player_count} active)")
            print(f"Total game stats in database: {stats_count}")
            
            # Get some sample players
            sample_players = self.session.query(Player).limit(5).all()
            if sample_players:
                print("\nSample players in database:")
                for i, p in enumerate(sample_players):
                    stats_count = self.session.query(PlayerStats).filter_by(player_id=p.player_id).count()
                    print(f"  {i+1}. {p.full_name} (ID: {p.player_id}): {stats_count} games")
        
        return True
    
    def run_all_tests(self, player_id=None):
        """Run all tests"""
        print("=" * 60)
        print("RUNNING ALL NBA DATA INGESTION TESTS")
        print("=" * 60)
        
        tests = [
            self.test_player_api,
            self.test_game_api,
            self.test_process_game_data,
            self.test_db_connection_and_schema,
            lambda: self.test_single_player_ingestion(player_id=player_id),
            lambda: self.verify_data_in_tables(player_id=player_id)
        ]
        
        success_count = 0
        
        for test in tests:
            try:
                if test():
                    success_count += 1
            except Exception as e:
                print(f"❌ Test failed with exception: {e}")
        
        print("\n" + "=" * 60)
        print(f"TEST SUMMARY: {success_count}/{len(tests)} tests passed")
        print("=" * 60)

if __name__ == "__main__":
    # Parse command line arguments
    import argparse
    
    parser = argparse.ArgumentParser(description="Test the NBA data ingestion process")
    parser.add_argument("--player-id", type=int, help="Specific player ID to test with")
    parser.add_argument("--test", choices=["all", "api", "process", "db", "ingestion", "verify"], 
                        default="all", help="Specific test to run")
    parser.add_argument("--season", type=str, default="2023-24", help="Season to use for testing")
    
    args = parser.parse_args()
    
    tester = TestNBAIngestion()
    
    try:
        if args.test == "all":
            tester.run_all_tests(player_id=args.player_id)
        elif args.test == "api":
            tester.test_player_api()
            tester.test_game_api(player_id=args.player_id, season=args.season)
        elif args.test == "process":
            tester.test_process_game_data(player_id=args.player_id, season=args.season)
        elif args.test == "db":
            tester.test_db_connection_and_schema()
        elif args.test == "ingestion":
            tester.test_single_player_ingestion(player_id=args.player_id, season=args.season)
        elif args.test == "verify":
            tester.verify_data_in_tables(player_id=args.player_id)
    finally:
        tester.cleanup()

================
File: backend/app.py
================
from flask import Flask, jsonify
from flask_cors import CORS # allows frontend to make request to the server
import requests
from datetime import datetime
import os
from dotenv import load_dotenv  
from backend.ml.ml_model import NBAPredictor 

load_dotenv()  # loads environment variables from .env file

app = Flask(__name__) # initialize Flask application, __name__ represents the name of the current module
CORS(app) # enables Cross-Origin Resource Sharing, allow requests from different origins


API_KEY = os.getenv('ODDS_API_KEY')
if not API_KEY: # if API_KEY is empty or falsy
    raise ValueError("Missing ODDS_API_KEY environment variable. Make sure you have a .env file with this value.")

BASE_URL = "https://api.the-odds-api.com/v4"

def calculate_confidence(odds):
    """
    Calculate confidence score based on betting odds.
    Returns a value between 0 and 1.
    """
    try:
        if odds > 0:
            probability = 100 / (odds + 100)
        else:
            probability = abs(odds) / (abs(odds) + 100)
        return round(probability, 3)
    except (TypeError, ZeroDivisionError):
        return None

# decorator, get_picks() will run when a HTTP request hits the server with the path "/api/picks", return value is sent back to client
@app.route("/api/picks", methods=["GET"]) # methods=["GET"] is not necssary since it is the default HTTP method, included for clarity
def get_picks():
    try:
        response = requests.get(
            # f-string
            f"{BASE_URL}/sports/basketball_nba/odds",
            params={
                "apiKey": API_KEY,
                "regions": "us",
                "markets": "h2h",
                "oddsFormat": "american"
            }
        )

        if response.status_code != 200: # 200 indicates a successful request
            print(f"API Error: {response.status_code}", response.text)
            # HTTP status code for the response, 500 indicates Internal Server Error
            return jsonify({"error": "Failed to fetch from Odds API"}), 500
            
        games = response.json()
        processed_games = []
        
        for idx, game in enumerate(games):
            try:
                # Skip games without odds data
                if not game.get('bookmakers'):
                    continue
                    
                bookmaker = game['bookmakers'][0]
                odds = bookmaker['markets'][0]['outcomes']
                
                # Find home and away team odds
                home_odds = None
                away_odds = None
                for odd in odds:
                    if odd['name'] == game['home_team']:
                        home_odds = odd['price']
                        break

                for odd in odds:
                    if odd['name'] == game['away_team']:
                        away_odds = odd['price']
                        break
                
                if home_odds is None or away_odds is None:
                    continue
                
                # Calculate confidence scores
                home_confidence = calculate_confidence(home_odds)
                away_confidence = calculate_confidence(away_odds)
                
                if home_confidence is None or away_confidence is None:
                    continue
                
                # Determine prediction
                if home_confidence > away_confidence:
                    predicted_winner = game['home_team']
                    confidence = home_confidence
                else:
                    predicted_winner = game['away_team']
                    confidence = away_confidence

                processed_games.append({
                    "id": str(idx + 1),
                    "team": game['home_team'],
                    "opponent": game['away_team'],
                    "prediction": f"{predicted_winner} Win",
                    "confidence": confidence,
                    "start_time": game['commence_time'],
                    "odds": {
                        "home_odds": home_odds,
                        "away_odds": away_odds
                    }
                })
                
            except Exception as e:
                print(f"Error processing game {idx}: {str(e)}")
                continue
        
        return jsonify(processed_games)

    except requests.exceptions.RequestException as e:
        print(f"Request error: {str(e)}")
        return jsonify({"error": "Failed to fetch game data"}), 500
    except Exception as e:
        print(f"Unexpected error: {str(e)}")
        return jsonify({"error": "An unexpected error occurred"}), 500
    

@app.route("/api/props", methods=["GET"])
def get_player_props():
    try:
        # Get all NBA games
        games_response = requests.get(
            f"{BASE_URL}/sports/basketball_nba/events",
            params={
                "apiKey": API_KEY
            }
        )
        
        if games_response.status_code != 200:
            print(f"Games API Error: {games_response.status_code}", games_response.text)
            return jsonify({"error": "Failed to fetch games"}), 500
            
        games = games_response.json()
        processed_props = []
        
        # For each game, get player props
        for game in games:
            try:
                props_response = requests.get(
                    f"{BASE_URL}/sports/basketball_nba/events/{game['id']}/odds",
                    params={
                        "apiKey": API_KEY,
                        "regions": "us",
                        "markets": "player_points,player_rebounds,player_assists",
                        "oddsFormat": "american",
                        "bookmakers": "draftkings"
                    }
                )
                
                if props_response.status_code != 200:
                    continue
                    
                props_data = props_response.json()
                
                # Process bookmaker data
                if not props_data.get('bookmakers'):
                    continue
                    
                bookmaker = props_data['bookmakers'][0]  # DraftKings
                
                for market in bookmaker['markets']:
                    for outcome in market['outcomes']:
                        confidence = calculate_confidence(outcome['price'])
                        if confidence is None:
                            continue
                            
                        processed_props.append({
                            "id": f"{game['id']}-{market['key']}-{outcome['name']}",
                            "game": f"{game['home_team']} vs {game['away_team']}",
                            "start_time": game['commence_time'],
                            "name": outcome['name'], 
                            "player": outcome['description'],
                            "market": market['key'].replace('player_', '').title(),
                            "line": outcome['point'],
                            "odds": outcome['price'],
                            "confidence": confidence
                        })
                        
            except Exception as e:
                print(f"Error processing props for game {game['id']}: {str(e)}")
                continue

        # Sort by confidence descending
        processed_props.sort(key=lambda x: x['confidence'], reverse=True)
        
        # Return top 10 most confident props
        return jsonify(processed_props[:10])

    except requests.exceptions.RequestException as e:
        print(f"Request error: {str(e)}")
        return jsonify({"error": "Failed to fetch prop data"}), 500
    except Exception as e:
        print(f"Unexpected error: {str(e)}")
        return jsonify({"error": "An unexpected error occurred"}), 500

if __name__ == "__main__": # starts the Flask Development Server
    app.run(debug=True, host='0.0.0.0')

================
File: backend/db_config.py
================
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base, sessionmaker

DATABASE_URL = os.getenv('DATABASE_URL', 'postgresql://localhost:5432/nba_betting')

engine = create_engine(DATABASE_URL)
Base = declarative_base()

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

================
File: backend/dockerfile
================
# Use the official Python image
FROM python:3.9

# Set the working directory
WORKDIR /app

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy the application code
COPY . .

# Expose the Flask default port
EXPOSE 5000

# Run the Flask app
CMD ["flask", "run", "--host=0.0.0.0"]

================
File: backend/readme.md
================
## <u> backend </u>

### backend structure

backend/  
├── models/  
│   └── database.py        
├── scripts/  
│   └── ingest_historical_stats.py  
├── visualizations/  
│   ├── outputs/          
│   └── visualize_playerstats.py    
├── app.py  
├── dockerfile                 
├── init_db.py                   
└── requirements.txt     
<hr>
<br>
```database.py``` defines what data can be stored (table structures) -> ```db_init.py``` creates the actual database and tables -> ```ingestion.py``` uses ```database.py``` and ```db_init.py``` to fetch NBA data and stores it in the correct format.

<br>

Using the SQLAlchemy ORM (Object Relational Mapping) in ```database.py```, the application is able to translate between Python objects and database records, meaning the database records can be manipulated in Python.


<hr>


### <u>models/database.py </u>
defines the SQLAlchemy ORM models for the player stats database

ORM (Object-Relational Mapping) models allow us to interact with database records with Python objects without writing SQL queries

example:  
instead of 
```sql 
SELECT * FROM players WHERE player_id = 123;
```
we can write
```python
player = Player.query.filter_by(player_id=123).first()
```
<hr>

### <u>  ingest_historical_stats.py </u>
fetches and stores player statistics from the last 5 regular seasons making calls to [nba_api](https://github.com/swar/nba_api) (created by [swar](https://github.com/swar))

- comprehensive logging functionality
- batch processing with rate limiting  

#### Core components
##### NBADataIngestion

- Manages player data retrieval and processing
- Implements session management

##### Database Storage

- table ```players```: basic player information  
- table ```player_stats```: per-game statistics for each player


<hr>


### <u> init_db.py </u>
Initializes PostgreSQL database for the app

- Sets up required tables and schema
- database configuration verification
- detailed logging


#### Database Schema
<u>Players Table</u>

```properties
id: Primary key
player_id: Unique NBA ID
full_name: Player name
is_active: Active status
```


<u> PlayerStats Table </u>

```properties
id: Primary key
game_id: Game identifier
player_id: Foreign key to Players
game_date: DateTime
season: String
is_home_game: Boolean
minutes_played: String
points: Integer
assists: Integer
rebounds: Integer
steals: Integer
blocks: Integer
turnovers: Integer
plus_minus: Integer
fg_made: Integer
fg_attempted: Integer
fg3_made: Integer
fg3_attempted: Integer
ft_made: Integer
ft_attempted: Integer
```

<hr>

### Opening the PostgreSQL tables in Excel (for my own reference)
1. connect to the database psql in command line ```postgresql://localhost:5432/nba_betting```
2. \dt to view tables in the database
3. ```\copy (SELECT * FROM <table_name>) '~/Documents/Sharpshooter Picks/<table_name>.csv' CSV HEADER```
single quotations are used in the filepath because there's a space in the folder name
ex. ```\copy (SELECT * FROM players) '~/Documents/Sharpshooter Picks/players.csv' CSV HEADER```
ex. ```\copy (SELECT * FROM player_stats) '~/Documents/Sharpshooter Picks/player_stats.csv' CSV HEADER```

================
File: backend/requirements.txt
================
requests>=2.26.0
Flask>=2.0.0
flask-cors>=4.0.0
python-dotenv>=0.19.0
pandas>=1.3.0
numpy>=1.21.0
typing>=3.7.4
torch>=2.0.0
nba_api==1.7.0
sqlalchemy>=2.0.0
psycopg2-binary>=2.9.0
SQLAlchemy-Utils>=0.41.0

================
File: frontend/components/BettingDashboard.jsx
================
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { AlertCircle, TrendingUp, DollarSign } from 'lucide-react';

const BettingDashboard = () => {
  // State to hold betting data for different categories
  const [bets, setBets] = useState({
    overall: [],
    draftkings: [],
    fanduel: []
  });
  // Loading state to indicate if data is being fetched
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Simulate fetching betting data (replace with real API calls)
    const fetchBets = async () => {
      try {
        setIsLoading(true);
        // Simulate API delay
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Mock data for demonstration purposes
        const mockData = {
          overall: [
            {
              id: 1,
              game: "Celtics vs Lakers",
              pick: "Celtics -5.5",
              odds: -110,
              confidence: 0.85,
              time: "7:30 PM ET",
              book: "DraftKings"
            },
            {
              id: 2,
              game: "Warriors vs Suns",
              pick: "Over 235.5",
              odds: -105,
              confidence: 0.82,
              time: "10:00 PM ET",
              book: "FanDuel"
            }
          ],
          draftkings: [
            {
              id: 3,
              game: "Celtics vs Lakers",
              pick: "Celtics -5.5",
              odds: -110,
              confidence: 0.85,
              time: "7:30 PM ET"
            }
          ],
          fanduel: [
            {
              id: 4,
              game: "Warriors vs Suns",
              pick: "Over 235.5",
              odds: -105,
              confidence: 0.82,
              time: "10:00 PM ET"
            }
          ]
        };
        
        // Update state with the fetched (or mocked) data
        setBets(mockData);
      } catch (error) {
        console.error('Error fetching bets:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchBets();
  }, []);

  // Component to render an individual bet card
  const BetCard = ({ bet }) => (
    <Card className="mb-4 hover:shadow-lg transition-shadow">
      <CardContent className="pt-6">
        {/* Header section with game info and confidence indicator */}
        <div className="flex justify-between items-start mb-4">
          <div>
            <h3 className="font-semibold text-lg text-gray-900">{bet.game}</h3>
            <p className="text-sm text-gray-500">{bet.time}</p>
          </div>
          <div className="text-right">
            {/* Confidence badge with color based on confidence level */}
            <div className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium
              ${bet.confidence >= 0.8 ? 'bg-green-100 text-green-800' : 
                bet.confidence >= 0.7 ? 'bg-yellow-100 text-yellow-800' : 
                'bg-red-100 text-red-800'}`}>
              {(bet.confidence * 100).toFixed(0)}% Confidence
            </div>
            {/* Display bookmaker if available */}
            {bet.book && (
              <p className="text-sm text-gray-500 mt-1">{bet.book}</p>
            )}
          </div>
        </div>
        
        {/* Section with betting pick and odds */}
        <div className="flex justify-between items-center">
          <div className="flex items-center space-x-2">
            <TrendingUp className="w-4 h-4 text-gray-500" />
            <span className="font-medium">{bet.pick}</span>
          </div>
          <div className="flex items-center space-x-2">
            <DollarSign className="w-4 h-4 text-gray-500" />
            <span className={`font-medium ${bet.odds > 0 ? 'text-green-600' : 'text-red-600'}`}>
              {bet.odds > 0 ? `+${bet.odds}` : bet.odds}
            </span>
          </div>
        </div>
      </CardContent>
    </Card>
  );

  // Component to render content for a specific tab (list of bets)
  const TabContent = ({ bets }) => (
    <div className="space-y-4">
      {isLoading ? (
        // Display a spinner while loading data
        <div className="flex justify-center items-center h-64">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900" />
        </div>
      ) : bets.length > 0 ? (
        // Map over bets and render a BetCard for each
        bets.map(bet => <BetCard key={bet.id} bet={bet} />)
      ) : (
        // Display a message when no bets are available
        <div className="text-center py-12">
          <AlertCircle className="mx-auto h-12 w-12 text-gray-400" />
          <h3 className="mt-2 text-sm font-medium text-gray-900">No bets available</h3>
          <p className="mt-1 text-sm text-gray-500">Check back later for new betting opportunities.</p>
        </div>
      )}
    </div>
  );

  return (
    <div className="max-w-4xl mx-auto p-4">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl font-bold">NBA Best Bets</CardTitle>
        </CardHeader>
        <CardContent>
          {/* Tabs to switch between overall bets and specific bookmakers */}
          <Tabs defaultValue="overall" className="w-full">
            <TabsList className="grid w-full grid-cols-3">
              <TabsTrigger value="overall">Overall Best Bets</TabsTrigger>
              <TabsTrigger value="draftkings">DraftKings</TabsTrigger>
              <TabsTrigger value="fanduel">FanDuel</TabsTrigger>
            </TabsList>
            <div className="mt-6">
              {/* Render the corresponding TabContent based on the selected tab */}
              <TabsContent value="overall">
                <TabContent bets={bets.overall} />
              </TabsContent>
              <TabsContent value="draftkings">
                <TabContent bets={bets.draftkings} />
              </TabsContent>
              <TabsContent value="fanduel">
                <TabContent bets={bets.fanduel} />
              </TabsContent>
            </div>
          </Tabs>
        </CardContent>
      </Card>
    </div>
  );
};

export default BettingDashboard;

================
File: frontend/components/BettingTabs.jsx
================
import { useState, useEffect } from 'react';
import * as Tabs from '@radix-ui/react-tabs';

export default function BettingTabs() {
    const [propsData, setPropsData] = useState([]);
    const [games, setGames] = useState([]);

    const [isLoadingProps, setIsLoadingProps] = useState(true);
    const [isLoadingGames, setIsLoadingGames] = useState(true);

    const [error, setError] = useState(null);

    useEffect(() => {
        const fetchProps = async () => {
            try {
                const response = await fetch('http://localhost:5001/api/props');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                setPropsData(data);
            } catch (e) {
                setError('Failed to load props: ' + e.message);
            } finally {
                setIsLoadingProps(false);
            }
        };

        const fetchGames = async () => {
            try {
                const response = await fetch('http://localhost:5001/api/picks');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                setGames(data);
            } catch (e) {
                setError('Failed to load games: ' + e.message);
            } finally {
                setIsLoadingGames(false);
            }
        };

        fetchProps();
        fetchGames();

        // Refresh data every 5 minutes
        const interval = setInterval(() => {
            fetchProps();
            fetchGames();
        }, 300000);

        return () => clearInterval(interval);
    }, []);

    const formatDate = (dateString) => {
        return new Date(dateString).toLocaleString('en-US', {
            weekday: 'short',
            month: 'short',
            day: 'numeric',
            hour: 'numeric',
            minute: '2-digit'
        });
    };

    const formatOdds = (odds) => (odds > 0 ? `+${odds}` : odds);

    return (
        <Tabs.Root defaultValue="games" className="w-full">
            {/* --- Tabs List --- */}
            <Tabs.List className="flex border-b border-gray-200">
                <Tabs.Trigger 
                    value="games" 
                    className="px-4 py-2 text-sm font-medium text-gray-600 hover:text-gray-900 cursor-pointer border-b-2 border-transparent data-[state=active]:border-blue-500 data-[state=active]:text-blue-600"
                >
                    Game Lines
                </Tabs.Trigger>
                <Tabs.Trigger 
                    value="props"
                    className="px-4 py-2 text-sm font-medium text-gray-600 hover:text-gray-900 cursor-pointer border-b-2 border-transparent data-[state=active]:border-blue-500 data-[state=active]:text-blue-600"
                >
                    Player Props
                </Tabs.Trigger>
            </Tabs.List>

            {/* --- GAMES TAB CONTENT --- */}
            <Tabs.Content value="games" className="mt-4">
                {isLoadingGames ? (
                    <div className="flex items-center justify-center h-64">
                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
                    </div>
                ) : error ? (
                    <div className="text-red-500 p-4 rounded-lg bg-red-50">
                        {error}
                    </div>
                ) : (
                    <div className="space-y-4">
                        {games.map((game) => (
                            <div key={game.id} className="border rounded-lg p-4 hover:shadow-lg transition-shadow bg-white">
                                <div className="flex justify-between items-center mb-2">
                                    <div>
                                        <h3 className="text-lg font-medium">
                                            {game.team} vs {game.opponent}
                                        </h3>
                                        <p className="text-sm text-gray-500">
                                            {formatDate(game.start_time)}
                                        </p>
                                    </div>
                                    <div className="text-right">
                                        <span className={`text-lg font-bold ${
                                            game.confidence > 0.7 ? 'text-green-600' : 
                                            game.confidence > 0.5 ? 'text-yellow-600' : 
                                            'text-red-600'
                                        }`}>
                                            {(game.confidence * 100).toFixed(1)}%
                                        </span>
                                    </div>
                                </div>

                                <div className="mt-2 space-y-2">
                                    <div className="flex justify-between text-sm">
                                        <span className="text-gray-600">Prediction:</span>
                                        <span className="font-medium">{game.prediction}</span>
                                    </div>
                                    <div className="flex justify-between text-sm">
                                        <span className="text-gray-600">Odds:</span>
                                        <span>
                                            {game.team}: {formatOdds(game.odds.home_odds)} | {game.opponent}: {formatOdds(game.odds.away_odds)}
                                        </span>
                                    </div>
                                </div>
                            </div>
                        ))}

                        {games.length === 0 && (
                            <div className="text-gray-500 text-center py-8">
                                No games available at the moment
                            </div>
                        )}
                    </div>
                )}
            </Tabs.Content>

            {/* --- PROPS TAB CONTENT --- */}
            <Tabs.Content value="props" className="mt-4">
                {isLoadingProps ? (
                    <div className="flex items-center justify-center h-64">
                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
                    </div>
                ) : error ? (
                    <div className="text-red-500 p-4 rounded-lg bg-red-50">
                        {error}
                    </div>
                ) : (
                    <div className="space-y-4">
                        {propsData.map((prop) => (
                            <div
                                key={prop.id}
                                className="border rounded-lg p-4 hover:shadow-lg transition-shadow bg-white"
                            >
                                <div className="flex justify-between items-center mb-2">
                                    <div>
                                        <h3 className="text-lg font-medium">{prop.player}</h3>
                                        <p className="text-sm text-gray-500">
                                            {prop.game}
                                        </p>
                                        <p className="text-sm text-gray-500">
                                            {formatDate(prop.start_time)}
                                        </p>
                                    </div>
                                    <div className="text-right">
                                        <span
                                            className={`text-lg font-bold ${
                                                prop.confidence > 0.7
                                                    ? 'text-green-600'
                                                    : prop.confidence > 0.5
                                                    ? 'text-yellow-600'
                                                    : 'text-red-600'
                                            }`}
                                        >
                                            {(prop.confidence * 100).toFixed(1)}%
                                        </span>
                                    </div>
                                </div>

                                <div className="mt-2 space-y-1 text-sm">
                                    <div className="flex justify-between">
                                        <span className='text-gray-600'>
                                            Over/Under:
                                        </span>
                                        <span className='font-medium'>
                                            {prop.name}
                                        </span> 
                                    </div>
                                    <div className="flex justify-between">
                                        <span className="text-gray-600">
                                            Market:
                                        </span>
                                        <span className="font-medium">
                                            {prop.market} ({prop.line})
                                        </span>
                                    </div>
                                    <div className="flex justify-between">
                                        <span className="text-gray-600">
                                            Odds:
                                        </span>
                                        <span>
                                            {formatOdds(prop.odds)}
                                        </span>
                                    </div>
                                </div>
                            </div>
                        ))}

                        {propsData.length === 0 && (
                            <div className="text-gray-500 text-center py-8">
                                No player props available at the moment
                            </div>
                        )}
                    </div>
                )}
            </Tabs.Content>
        </Tabs.Root>
    );
}

================
File: frontend/components/TopPicks.js
================
import { useState, useEffect } from 'react';


// Displays the top betting picks of the day as determined by the system
export default function TopPicks({ onGameSelect }) {
    const [games, setGames] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        const fetchGames = async () => {
            try {
                const response = await fetch('http://localhost:5001/api/picks');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                setGames(data);
            } catch (e) {
                setError('Failed to load picks: ' + e.message);
            } finally {
                setIsLoading(false);
            }
        };

        fetchGames();
        // Refresh data every 5 minutes
        const interval = setInterval(fetchGames, 300000);
        return () => clearInterval(interval);
    }, []);

    const formatDate = (dateString) => {
        return new Date(dateString).toLocaleString('en-US', {
            weekday: 'short',
            month: 'short',
            day: 'numeric',
            hour: 'numeric',
            minute: '2-digit'
        });
    };

    // Format odds for display
    const formatOdds = (odds) => {
        return odds > 0 ? `+${odds}` : odds;
    };

    if (isLoading) {
        return (
            <div className="flex items-center justify-center h-64">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
            </div>
        );
    }

    if (error) {
        return (
            <div className="text-red-500 p-4 rounded-lg bg-red-50">
                {error}
            </div>
        );
    }

    return (
        <div className="space-y-4">
            {games.map((game) => (
                <div
                    key={game.id}
                    className="border rounded-lg p-4 hover:shadow-lg transition-shadow cursor-pointer bg-white"
                    onClick={() => onGameSelect(game)}
                >
                    {/* Game Header */}
                    <div className="flex justify-between items-center mb-2">
                        <div>
                            <h3 className="text-lg font-medium">
                                {game.team} vs {game.opponent}
                            </h3>
                            <p className="text-sm text-gray-500">
                                {formatDate(game.start_time)}
                            </p>
                        </div>
                        <div className="text-right">
                            <span className={`text-lg font-bold ${
                                game.confidence > 0.7 ? 'text-green-600' : 
                                game.confidence > 0.5 ? 'text-yellow-600' : 
                                'text-red-600'
                            }`}>
                                {(game.confidence * 100).toFixed(1)}%
                            </span>
                        </div>
                    </div>

                    {/* Prediction & Odds */}
                    <div className="mt-2 space-y-2">
                        <div className="flex justify-between text-sm">
                            <span className="text-gray-600">Prediction:</span>
                            <span className="font-medium">{game.prediction}</span>
                        </div>
                        <div className="flex justify-between text-sm">
                            <span className="text-gray-600">Odds:</span>
                            <span>
                                {game.team}: {formatOdds(game.odds.home)} | {game.opponent}: {formatOdds(game.odds.away)}
                            </span>
                        </div>
                    </div>
                </div>
            ))}

            {games.length === 0 && (
                <div className="text-gray-500 text-center py-8">
                    No games available at the moment
                </div>
            )}
        </div>
    );
}

================
File: frontend/pages/_app.js
================
import '../styles/globals.css';

function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />;
}

export default MyApp;

================
File: frontend/pages/index.js
================
import BettingDashboard from '../components/BettingDashboard';

export default function Home() {
    return (
        <div className="min-h-screen bg-gray-50">
            <header className="bg-white shadow">
                <div className="max-w-7xl mx-auto py-6 px-4">
                    <h1 className="text-3xl font-bold text-gray-900">
                        NBA Betting Dashboard
                    </h1>
                </div>
            </header>

            <main className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
                <BettingDashboard />
            </main>
        </div>
    );
}

================
File: frontend/styles/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

================
File: frontend/dockerfile
================
# Use Node.js as our base image
FROM node:18-alpine

# Set working directory in the container
WORKDIR /app

# Copy package files first (this helps with caching)
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of the application
COPY . .

# Expose the port Next.js runs on
EXPOSE 3000

# Start the development server
CMD ["npm", "run", "dev"]

================
File: frontend/package.json
================
{
  "name": "frontend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@radix-ui/react-slot": "^1.1.1",
    "@radix-ui/react-tabs": "^1.1.2",
    "@shadcn/ui": "^0.0.4",
    "autoprefixer": "^10.4.20",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.471.1",
    "next": "^15.1.4",
    "postcss": "^8.5.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwindcss": "^3.4.17",
    "tailwindcss-animate": "^1.0.7"
  }
}

================
File: frontend/postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: frontend/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: [
      "./app/**/*.{js,ts,jsx,tsx,mdx}",
      "./pages/**/*.{js,ts,jsx,tsx,mdx}",
      "./components/**/*.{js,ts,jsx,tsx,mdx}",
    ],
    theme: {
      extend: {},
    },
    plugins: [],
  }

================
File: notes/testing/nba_api_sandbox.py
================
from nba_api.stats.static import players
from nba_api.stats.endpoints import leaguegamefinder
import pandas as pd
import random

# Step 1: get active players and select one
active_players = players.get_active_players()

king_james = [player for player in active_players if player['full_name'] == "Jayson Tatum"][0]
player_id = king_james['id']
print(f"Selected Player: {king_james['full_name']} (ID: {player_id})")

# Step 2: retrieve games for the player

seasons = [
   "2024-25",
   "2023-24",
   "2022-23", 
   "2021-22",
   "2020-21"
]

for season in seasons:

    gamefinder = leaguegamefinder.LeagueGameFinder(
        player_or_team_abbreviation="P",
        player_id_nullable=player_id,
        season_type_nullable="Regular Season",
        season_nullable=season
    ) 

    # converts gamefinder into a pandas dataframe
    games_df = gamefinder.get_data_frames()[0]

    print(games_df.head()) # first 5 rows
    print(games_df.columns) # gives column labels (ex. plyer names, points scored)
    print(games_df.index) # gives row index
    print(games_df.index.tolist()) 

    season_id = games_df['SEASON_ID'].iloc[0]  # '22019'
    year = int(season_id[1:])  # 2019
    formatted_year = f"{year}-{str(year+1)[2:]}" # '2019-20'

    print(f"Found {len(games_df)} games for {king_james['full_name']} during the {formatted_year} regular season.")

minimum_season = 0
max_season = len(seasons) - 1
random_season = seasons[random.randint(minimum_season, max_season)]

print(random_season)

gamefinder = leaguegamefinder.LeagueGameFinder(
    player_or_team_abbreviation="P",
    player_id_nullable=player_id,
    season_type_nullable="Regular Season",
    season_nullable=random_season
)

games_df = gamefinder.get_data_frames()[0]

cols_to_describe = [col for col in games_df.columns if col != "TEAM_ID"]
print(games_df[cols_to_describe].describe())

print(games_df['MIN'])
print(games_df.iloc[1]) # (integer location) accesses the second row

# games_df = gamefinder.get_data_frames()[0]

# minimum_game = 0
# maximum_game = len(games_df) - 1 # number of total games played that season
# random_game = games_df.iloc[random.randint(minimum_game, maximum_game)]
# print(random_game)

================
File: notes/nba_api.md
================
![package structure](images/image.png)


##### finding all active players
- from nba_api.stats.static import players
- players.get_active_players()
```JSON
    player = {
        'id': player_id,
        'full_name': full_name,
        'first_name': first_name,
        'last_name': last_name,
        'is_active': True or False
    }
``` 

##### Find every game a player has ever played
```python
gamefinder = leaguegamefinder.LeagueGameFinder(
    player_or_team_abbreviation="P",
    player_id_nullable=player_id,
    season_type_nullable=regular,
    season_nullable="2019-20"
)   
```

##### Get a list of games only within the last 5 seasons


#### BoxScore for a particular game
##### nba_api -> live -> endpoints
- [BoxScore](https://github.com/swar/nba_api/blob/master/docs/nba_api/live/endpoints/boxscore.md)


###### nba_api -> stats -> endpoints
- [CumeStatsPlayerGames](https://github.com/swar/nba_api/blob/master/docs/nba_api/stats/endpoints/cumestatsplayergames.md)
- [LeagueGameFinder](https://github.com/swar/nba_api/blob/master/docs/nba_api/stats/endpoints/leaguegamefinder.md)
can be used to retrieve every game a player has played 
    ```python
    gamefinder = leaguegamefinder.LeagueGameFinder(
        player_or_team_abbreviation="P",
        player_id_nullable=player_id
    )   
    ```


.get_data_frames() 
- helper function provided by the API

================
File: notes/pandas.md
================
pandas.DataFrame.describe()
- 

pandas.DataFrame.columns
- gives column labels

pandas.DataFrame.index 
- gives row labels


pandas.DataFrame[<column-label>] 
- returns the entire column as a Series

pandas.DataFrame.iloc[int]
- short for integer location
- returns the row associated with that index

pandas.DataFrame[<column-label>].iloc[int]
- returns the item at [<column-label>, int]

pandas.DataFrame.iloc[int, int]
- purely positional indexing

================
File: notes/todo.txt
================
Complete the ML Model Implementation


Connect Backend Endpoints to ML Model

Connect Frontend to Real API

Fix Database Connection Issues


display bookmaker odds vs. SharpshooterPicks calculated odds

discssuion forum where users can discuss bets

================
File: .env.example
================
# Instead of your actual API key
ODDS_API_KEY=your_api_key_here

================
File: .gitignore
================
# Dependencies
node_modules/
/.pnp
.pnp.js

# Next.js
/frontend/.next/
/out/

# Production
/build

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
.env*.local

# Debug logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# IDE files
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Python
__pycache__/
*.py[cod]
*$py.class
venv/
.env/
*.pyc
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Docker
.docker/
docker-compose.override.yml

# Coverage and test reports
.coverage
htmlcov/
.pytest_cache/
coverage/
.nyc_output

# Database
*.sqlite3
*.db

# Logs
logs/
*.log

# System Files
.DS_Store
Thumbs.db

repomix-output.txt

================
File: docker-compose.yml
================
version: '3.8'

services:
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    depends_on:
      - backend
    environment:
      - NODE_ENV=development
      - CHOKIDAR_USEPOLLING=true  # Enable polling for file changes
    volumes:
      - ./frontend:/app           # Mount the frontend source code
      - /app/node_modules         # Prevent overwriting node_modules
    command: npm run dev          # Ensure the dev server is running

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      - FLASK_APP=app.py
      - FLASK_ENV=development
      - ODDS_API_KEY=${ODDS_API_KEY}  # Uses value from .env file
    ports:
      - "5001:5000"
    depends_on:
      - db
    volumes:
      - ./backend:/app            # Mount the backend source code
      - /app/venv                 # If using a virtual environment

  db:
    image: postgres:14
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:

================
File: readme.md
================
# Welcome to Sharpshooter Picks! 
<hr>

## Description:
**Sharpshooter Picks** 🏀 is a full stack web-app built for selecting the **best NBA player proposition bets** using **Machine Learning**.
Models are trained on [nba_api](https://github.com/swar/nba_api)  and picks are found using [odds-api](https://the-odds-api.com/).


Users can also individually choose from the most popular bookmakers, including DraftKings, Fanduel, and BetMGM

<hr>

## 🛠️ Tech Stack

### Frontend

- Framework: Next.js (React)
- UI Components:
  - shadcn/ui components
  - Radix UI primitives
  - Lucide React icons


- Styling: Tailwind CSS
- Data Fetching: Native fetch API with interval updates

### Backend

- Framework: Flask (Python)
- Database: PostgreSQL with SQLAlchemy ORM
- Data Sources:
  - NBA API for historical player statistics
  - The Odds API for live betting odds


- Machine Learning: PyTorch

- Key Libraries:
  - pandas
  - numpy
  - requests
  - python-dotenv



### DevOps

- Containerization: Docker / Docker Compose
- Repomix (converts the entire project into a .txt file)
    - from the root directory, run ```repomix --ignore "frontend/node_modules/**,frontend/.next/**,player_stats.csv,players.csv"```

<hr>


## 📊 Data Pipeline

![SharpshooterPicks Data Pipeline](notes/images/SharpshooterPicks-data-pipeline.drawio.png)

1. Gather all currently active players from nba_api (One time)
2. For each player, gather stats for every game for that player within the last 5 years (One time)
3. Machine learning model training (One time)
4. Real time fetching of  player proposition bets for the day from all bookmakers listed in odds-api that support player prop betting 
5. Confidence score calculation, calculates which bets have the highest chance of hitting
6. Frontend displays bets with the highest confidence score and updates
